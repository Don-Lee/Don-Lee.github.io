---
layout:     post
title:      浅谈单例模式
subtitle:   
date:       2019-09-27
author:     Don
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 设计模式
    - Interview
---

在日常开发中，单例模式是我们计较常用的设计模式之一，今天，我们就来看一下单例模式的几种实现。

#### 定义   
确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例

单例模式是一种对象创建型模式。

#### 单例模式3要素  

1. 声明一个类型为自身的静态私有成员变量   
2. 声明一个公有的静态工厂方法，返回唯一实例  
3. 将构造函数的可见性修改为private  

#### 饿汉式单例  
饿汉式单例的实例在类装载时进行创建。由于是在类装时候创建， 所以能够保证线程安全。

实现代码：
```java
public class EagerSingleton {
    private static EagerSingleton eagerSingleton = new EagerSingleton();
    private EagerSingleton() {

    }

    private static EagerSingleton getInstance() {
        return eagerSingleton;
    }
}
```

#### 懒汉式单例与双重校验锁

懒汉式单例的实例在第一次被引用时初始化。   

懒汉式单例存在一个很严重的问题：线程不安全。如果在高并发、多线程环境下实现懒汉式单例的话，可能会创建多个实例对象，为了解决这个问题，一般在实现懒汉式单例时会加同步锁，代码如下：   
```java 
public class LazySingleton {
    private static LazySingleton lazySingleton;
    private LazySingleton() {

    }

    private static LazySingleton getInstance() {
        //第一重判断，判断实例是否存在，不存在则加锁创建
        if (lazySingleton == null) {
            //上锁，某一时刻只允许一个线程访问
            synchronized (LazySingleton.class) {
                //第二重判断
                if (lazySingleton == null) {
                    lazySingleton = new LazySingleton();
                }
            }

        }

        return lazySingleton;
    }
}
```

有的同学可能会说直接使用synchronized修改getInstance()方法不就可以了吗，不用这么麻烦。是，直接修饰方法确实可以达到效果，但是众所周知，synchronized效率低，而且只有当其修饰的代码块执行完成后才会释放锁，因此synchronized修饰的代码能少则少。


####  静态内部类单例
静态内部类单例的实例在第一次被引用时初始化。线程安全。
代码实现：
```java
public class StaticInnerClassSingleton {
    private static StaticInnerClassSingleton staticInnerClassSingleton;
    private StaticInnerClassSingleton() {

    }

    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    static class SingletonHolder{
        static StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
}
```

#### 总结

